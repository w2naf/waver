PRO GSPOS,GL=gl,RELOAD=reload
COMMON RAD_DATA_BLK

sim             = 1

IF KEYWORD_SET(reload) THEN BEGIN
@event
thick           = 4 
!P.THICK        = thick
!X.THICK        = thick
!Y.THICK        = thick
!P.CHARTHICK    = thick

;
;coord           = 'magn'
;mapXRange       = [-20, 25]
;mapYRange       = [-30, 15]

;beamRange       = [ 0,15]
;gateRange       = [20,60]

beamRange       = [ 3, 9]
gateRange       = [33,39]
s               = TEMPORARY(dRange)

coord           = 'geog'
mapXRange       = [-15, 15]
mapYRange       = [-40,-10]

lrdMapXRange       = [-2, 8]
lrdMapYRange       = [-35,-25]
lrdRotate       = 65.
rotate          = lrdRotate

SET_COORDINATES,coord
SET_PARAMETER,param

IF  N_ELEMENTS(date) EQ 1 THEN date = date[0] * [1,1]
RAD_FIT_READ,date,radar,TIME=time
inx             = RAD_FIT_GET_DATA_INDEX()

TIMESTEP,date,time,dateVec,timeVec,STEP=timeStep,JULS=julVec,/ODD
nSteps  = N_ELEMENTS(julVec)
nSteps$ = NUMSTR(nSteps)

FOR step=0,nSteps-1 DO BEGIN
    scan_number = RAD_FIT_FIND_SCAN(julVec[step])

    stId            =  (*RAD_FIT_INFO[inx]).id
    scanInx         =  WHERE( (*rad_fit_data[inx]).beam_scan EQ scan_number)

    juls            =  (*rad_fit_data[inx]).juls[scanInx]
    scan_id         = ((*rad_fit_data[inx]).scan_id[scanInx])[0]

    scan_startJul   = MIN(juls)
    juls$           = JUL2STRING(juls)

    ctrArr              = RAD_FIT_RBPOS_SCAN(scan_number,/CENTER)
    bndArr              = RAD_FIT_RBPOS_SCAN(scan_number)

    ctrArr_no_gs        = RAD_FIT_RBPOS_SCAN(scan_number,/NO_GS,/CENTER)
    bndArr_no_gs        = RAD_FIT_RBPOS_SCAN(scan_number,/NO_GS)

    ctrArr_grid         = RAD_FIT_RBPOS_SCAN(scan_number,/ALWAYS_GS,/CENTER)
    bndArr_grid         = RAD_FIT_RBPOS_SCAN(scan_number,/ALWAYS_GS)

    local_inx           = RAD_FIT_INX_SIMPLESCAN(scan_number,GLOBAL_INX=global_inx)

    ctrArr              = ctrArr[*,local_inx,*]
    bndArr              = bndArr[*,*,*,local_inx,*] 
    ctrArr_no_gs        = ctrArr_no_gs[*,local_inx,*]
    bndArr_no_gs        = bndArr_no_gs[*,*,*,local_inx,*] 
    ctrArr_grid         = ctrArr_grid[*,local_inx,*]
    bndArr_grid         = bndArr_grid[*,*,*,local_inx,*] 
    dataArr             = (*rad_fit_data[inx]).power[global_inx,*]
    beamVec             = (*rad_fit_data[inx]).beam[global_inx]

    badInx              = WHERE(dataArr EQ 10000, cnt)
    IF cnt NE 0 THEN dataArr[badInx] = !VALUES.F_NAN

    nBeams              = (SIZE(dataArr,/DIM))[0]
    nGates              = (SIZE(dataArr,/DIM))[1]

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Beam-Linear Interpolation ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;    ;Beam interpolation
    interpArr       = dataArr*0.
    FOR bk=0,nbeams-1 DO BEGIN
        goodInx         = WHERE(FINITE(dataArr[bk,*]), cnt)
        IF cnt LE 2 THEN CONTINUE
        result          = INTERPOL(REFORM(dataArr[bk,goodInx])          $
                                  ,REFORM(ctrArr[3,bk,goodInx])         $
                                  ,REFORM(ctrArr_grid[3,bk,*]))
        ;Force result to be positive.
        interpArr[bk,*] = result > 0
    ENDFOR


    IF KEYWORD_SET(dRange) AND ~KEYWORD_SET(gateRange) THEN BEGIN
        gateRange       = INTARR(2)

        srch            = WHERE(REFORM(ctrArr_grid[3,*,*]) GE dRange[0])
        ai              = ARRAY_INDICES(dataArr,srch)
        gateRange[0]    = MIN(ai[1,*])

        srch            = WHERE(REFORM(ctrArr_grid[3,*,*]) LE dRange[1])
        ai              = ARRAY_INDICES(dataArr,srch)
        gateRange[1]    = MAX(ai[1,*])
    ENDIF

    IF ~KEYWORD_SET(dRange) AND KEYWORD_SET(gateRange) THEN BEGIN
        min             = FLOOR(MIN(bndArr[3,*,*,*,gateRange[0]]))
        max             = CEIL(MAX(bndArr[3,*,*,*,gateRange[1]]))
        dRange          = [min, max]
    ENDIF

    selectArr  = interpArr[beamRange[0]:beamRange[1],gateRange[0]:gateRange[1]]

    IF ~KEYWORD_SET(loopComplete) THEN BEGIN
        beamInxArr = INTARR(nbeams,ngates)
        gateInxArr = INTARR(nbeams,ngates)

        FOR zz=0,nGates-1 DO beamInxArr[*,zz] = INDGEN(nbeams)
        FOR zz=0,nBeams-1 DO gateInxArr[zz,*] = INDGEN(nGates)

        selBeamArr = beamInxArr[beamRange[0]:beamRange[1],gateRange[0]:gateRange[1]]
        selGateArr = gateInxArr[beamRange[0]:beamRange[1],gateRange[0]:gateRange[1]]

        selBeamVec = REFORM(selBeamArr[*,0])
        selGateVec = REFORM(selGateArr[0,*])

        nSelBeams  = N_ELEMENTS(selBeamVec)
        nSelGates  = N_ELEMENTS(selGateVec)

        sel_ctrArr_grid = CTRARR_GRID[*,beamRange[0]:beamRange[1],gateRange[0]:gateRange[1]]
        sel_bndArr_grid = bndARR_GRID[*,*,*,beamRange[0]:beamRange[1],gateRange[0]:gateRange[1]]

        lr              = LRD(sel_ctrArr_grid,XCTR=xCtr,YCTR=yCtr,CTRLAT=ctrLat,CTRLON=ctrLon)
        lrBnd           = LRD_BND(sel_bndArr_grid,CTRLAT=ctrLat,CTRLON=ctrLon)

        ctrBm   = selBeamVec[xCtr]
        ctrRg   = selGateVec[yCtr]
        xspread = MAX(lr[0,*,*],/NAN) - MIN(lr[0,*,*],/NAN)
        yspread = MAX(lr[1,*,*],/NAN) - MIN(lr[1,*,*],/NAN)
        latspread       = MAX(sel_ctrArr_grid[0,*,*],/NAN) - MIN(sel_ctrArr_grid[0,*,*],/NAN)
        lonspread       = MAX(sel_ctrArr_grid[1,*,*],/NAN) - MIN(sel_ctrArr_grid[1,*,*],/NAN)

        IF KEYWORD_SET(gl) THEN BEGIN
            file    = DIR('output/kmaps/lrd.ps',/PS)
            @plot_lrd.pro
            PS_CLOSE
        ENDIF

        interpData      = FLTARR(nSteps,nSelBeams,nSelGates)
        scan_sJulVec    = DBLARR(nSteps)
    ENDIF

    interpData[step,*,*]    = selectArr
    scan_sJulVec[step]      = scan_startJul

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Plot stuff! ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    IF KEYWORD_SET(gl) THEN BEGIN
        OPEN_LOOP_PLOT,'output/kmaps/','gs_range',step
        @comp_gs_rang.pro
        PS_CLOSE

        OPEN_LOOP_PLOT,'output/kmaps/','raw_interp',step
        @comp_raw_interp.pro
        PS_CLOSE
    ENDIF       ;Graphics Level

    loopComplete        = 1
prinfo,'Time step ' + NUMSTR(step) + ' of ' + nSteps$
ENDFOR  ;Timestep Loop - step

SAVE
ENDIF ELSE RESTORE

keep_lr = 0
IF KEYWORD_SET(sim) THEN BEGIN
    rgNormalArr  = gwsim(LR=lr,BNDLR=lrBnd,JULS=julVec,KEEP_LR=keep_lr)
    @comp_sim_tid.pro
ENDIF ELSE BEGIN
    rgNormalArr  = NORMALIZE_RANGE(interpData)
    @plot_range_dep_remove.pro
ENDELSE

STOP
END
